{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Practica 2.5 Proxy Inverso y balanceo de carga con SSL en Nginx.","text":""},{"location":"#introduccion","title":"Introducci\u00f3n.","text":"<p>Una de las importantes funciones que tiene un proxy inverso era realizar un cifrado y descifrado de SSL para utilizar HTTPS en los servidores web. </p> <p></p> <p>El tr\u00e1fico de red entre el balanceador de carga y los servidores va sin cifrar (HTTP). Esto se debe a que normalmente en un caso real, el proxy y los servidores, adem\u00e1s de estar en la misma red privada suelen estar administrados por la misma empresa, por lo que no supone un peligro ese tr\u00e1fico sin cifrar. </p>"},{"location":"#certificados","title":"Certificados","text":"<p>HTTPS se basa en el uso de certificados digitales. Cuando accedemos a una web mediante HTTPS, nos presenta un certificado digital para asegurar de ser quien dice ser. La validez de este certificado se verifica en la Autoridad de Certificaci\u00f3n que emiti\u00f3 ese certificado si es v\u00e1lido. Los navegadores web tienen precargadas las Autoridades de Certificaci\u00f3n en las que conf\u00edan por defecto a la hora de navegar por web HTTPS.</p> <p>En caso de que no tenga certificado o no lo haya firmado la CA, nos saltar\u00e1 un aviso de que la p\u00e1gina web no es segura.</p>"},{"location":"#tarea","title":"Tarea.","text":"<p>Esquema objetivo de  la practica:</p> <p></p>"},{"location":"#creacion-de-certificado-autofirmado","title":"Creaci\u00f3n de certificado autofirmado.","text":"<p>Nosotros no utilizaremos certificados CA ya que nuestros servicios no est\u00e1 publicados en internet y esos certificados son de pago. Para su simulaci\u00f3n los crearemos y firmaremos nosotros mismos.  Para empezar, crearemos el directorio ssl en la carpeta nginx: </p> <pre><code>cd /etc/nginx\nmkdir ssl\n</code></pre> <p>Tras esto pondremos el siguiente comando para crear el certificado y las claves;</p> <pre><code>sudo openssl req -x509 -nodes - days 365 -newkey rsa:2048 -keyout /etc/ngix/ssl/server.key -out /etc/nginx/ssl/server.crt\n\n</code></pre> <p></p> <p>Si todo esta escrito correctamente. Como vemos en la imagen deberemos introducir unos parametros para el certificado. Como nuestra ciudad, email, centro...</p>"},{"location":"#desglose-de-comando","title":"Desglose de comando.","text":"<ul> <li>openssl: herramienta por linea de comandos para crear y administrar certificados u otros archivos OpenSSL</li> <li>req: subcomando utilizado para generar solicitud de certificados.</li> <li>-x509: Esto modifica el subcoando anterior al decirle que queremos crear un certificado autofirmado en lugar de solicitud de firma de certificado. </li> <li>-nodes: Esto le dice a OpenSSL que omita la opcion de asegurar nuestro certificado con contrase\u00f1a. Ya que necesitamos que nginx lo lea sin intervenci\u00f3n del usuario.</li> <li>-days 365: Aqu\u00ed definimos el tiempo que ser\u00e1 v\u00e1lida la clave. </li> <li>-newkey rsa:2048: Esto especifica que queremos crear un nuevo certificado y una nueva clave al mismo tiempo. </li> <li>-keyout: Este parametro indica d\u00f3nde colocar el archivo de clave privada. </li> <li>-out: Esto le dice a OpenSSL d\u00f3nde colocar el certificado que estamos creando. </li> </ul>"},{"location":"#configuracion-ssl-en-el-proxy-inverso","title":"Configuraci\u00f3n SSL en el Proxy inverso.","text":"<p>Ya visto anteriormente, nos iremos al archivo de configuraci\u00f3n del proxy ubicado en la ruta /etc/nginx/sites-avaliable. Este archivo lo editaremos para poner la configuraci\u00f3n para que el acceso al sitio web se realice mediante SSL. </p> <p>Dentro del bloque server{...}, cambiaremos el puerto de escucha listen 80 por lo que veis en la imagen de abajo. Quedar\u00e1 tal que as\u00ed: </p> <p></p>"},{"location":"#desglose-de-configuracion","title":"Desglose de configuraci\u00f3n.","text":"<p>Le estamos diciendo que escuche por el puerto 443, que es el puerto por defecto de HTTPS. Le hemos indicado el directorio donde est\u00e1 el certificado y la clave que hemos generado anteriormente.  Los protocoloes y tipos de cifrado que pueden utilizar y por \u00faltimo el archivo donde se guardan los logs cambia de nombre, ahora ser\u00e1 https_access.log. </p> <p>Tras este cambio de configuraci\u00f3n resetearemos el servicio de Nginx. </p> <pre><code>sudo systemctl restart nginx\n\n</code></pre>"},{"location":"#comprobaciones","title":"Comprobaciones.","text":"<p>Si accedemos ahora al balanceador, la primera vez nos dar\u00e1 un aviso ya que el certificado es autofirmado. Aceptaremos el riesgo y recargamos repetidamente la p\u00e1gina web con F5 vereis que el balanceo de carga se hace correctamente accediendo mediante https.  Para ver los detaller del certificado, le daremos click a conexi\u00f3n no segura, se nos despegar\u00e1 un men\u00fa y le daremos a la opci\u00f3n de detalles de certificado y nos saldr\u00e1 nuestro certificado con los datos introducidos. </p> <p></p>"},{"location":"#redireccion-forzosa-a-https","title":"Redirecci\u00f3n forzosa a HTTPS.","text":"<p>Para que, indistintivammente de la forma por la que accedamos al sitio web balanceo siempre fuerce a utilizar  HTTPS, necesitaremos configuraci\u00f3n adicional. A\u00f1adiremos un bloque de server que se quede tal que as\u00ed: </p> <p></p> <p>Con esto indicamos que escuche el puerto 80, que se guarde los logs de este bloque en ese directorio y con ese nombre. Cuando se reciba una petici\u00f3n con las dos condiciones anteriores, se devuelve un c\u00f3digo HTTP 301: -   HTTP 301 Moved Permanently: Es un c\u00f3digo de estado de HTTP que ha habido comunicaci\u00f3n entre el host y el servidor pero que el recurso solicitado ha sido movido a otra direcci\u00f3n permanentemente. Es muy importante configurar estas redirecciones en los sitios web. </p> <p>En conclusi\u00f3n, este bloque hace que cuando se reciba una petici\u00f3n HTTP (con el puerto 80) la redirija a HTTPS. </p>"},{"location":"#cuestiones","title":"Cuestiones.","text":"<ol> <li>Hemos configurado nuestro proxy inverso con todo lo que nos hace falta pero no nos funciona y da un error del tipo This site can't provide a secure connection, ERR_SSL_PROTOCOL_ERROR.</li> </ol> <p>Dentro de nuestro server block tenemos esto:</p> <pre><code>server {\n    listen 443;\n    ssl_certificate /etc/nginx/ssl/enrico-berlinguer/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/enrico-berlinguer/server.key;\n    ssl_protocols TLSv1.3;\n    ssl_ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS;\n    server_name enrico-berlinguer;\n    access_log /var/log/nginx/https_access.log;\n\n    location / {\n        proxy_pass http://red-party;\n        }\n    }\n\n</code></pre> <p>A\u00f1adiremos ssl tras 443 para indicarle que este bloque esta configurado para ssl. Soluci\u00f3n. </p> <pre><code>server {\n    listen 443 ssl;\n    ssl_certificate /etc/nginx/ssl/enrico-berlinguer/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/enrico-berlinguer/server.key;\n    ssl_protocols TLSv1.3;\n    ssl_ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS;\n    server_name enrico-berlinguer;\n    access_log /var/log/nginx/https_access.log;\n\n    location / {\n        proxy_pass http://red-party;\n        }\n    }\n\n</code></pre> <ol> <li>Imaginad que intentamos acceder a nuestro sitio web HTTPS y nos encontramos con el siguiente error:</li> </ol> <p></p> <p>Este aviso se produce cuando el navegador encuentran problemas con el certificado SSL de un sitio web, generalmente porque no provienen de la CA. La soluci\u00f3n ser\u00eda contratar los servicios y obtener un certificado de la CA. </p>"}]}